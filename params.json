{"name":"CI Base Model","tagline":"An extension of CodeIgniter's base Model class to remove repetition and increase productivity by providing a couple handy methods.","body":"CI_Base_Model\r\n=============\r\n\r\n[![Build Status](https://travis-ci.org/ronisaha/ci-base-model.png?branch=master)](https://travis-ci.org/ronisaha/ci-base-model)\r\n\r\nAn extension of CodeIgniter's base Model class to remove repetition and increase productivity by providing a couple handy methods. Most of the functionality\r\nof CI_Base_Model taken from following two library\r\n* [http://github.com/jamierumbelow/codeigniter-base-model](http://github.com/jamierumbelow/codeigniter-base-model)\r\n* [https://github.com/phpfour/MY_Model](https://github.com/phpfour/MY_Model)\r\n\r\n\r\nKey Features\r\n============\r\n* Basic CRUD Functionality\r\n* validation-in-model\r\n* Simple Event Callback system\r\n* Blamable\r\n* Soft-Deletable\r\n* Timestampable\r\n* Easy to use\r\n* Support both CamelCase and underscore version of a function (you can use findAll/find_all both will do the same). As codeigniter's convention the library implemented in underscore version of the functions\r\n\r\n\r\nSynopsis\r\n--------\r\n\r\n```php\r\nclass Post_model extends MY_Model { }\r\n\r\n$this->load->model('post_model', 'post');\r\n\r\n$this->post->get_all();\r\n\r\n$this->post->get(1);\r\n$this->post->get_by('title', 'Pigs CAN Fly!');\r\n$this->post->get_many_by('status', 'open');\r\n//or $this->post->getManyBy('status', 'open');\r\n\r\n$this->post->insert(array(\r\n    'status' => 'open',\r\n    'title' => \"I'm too sexy for my shirt\"\r\n));\r\n\r\n$this->post->update(1, array( 'status' => 'closed' ));\r\n\r\n$this->post->delete(1);\r\n```\r\n\r\nInstallation/Usage\r\n------------------\r\n\r\nDownload and copy the MY\\_Model.php and CI\\_Base\\_Model.php file into your _application/core_ folder. CodeIgniter will load and initialise this class automatically for you.\r\n\r\nExtend your model classes from `MY_Model` and all the functionality will be baked in automatically. You may wondering why we use two file? Here are the benefits.\r\n* You can implement all your global implementation in MY_Model.\r\n* You can update CI_Base_Model any time. Your oun global implementation will not affected.\r\n\r\n**Note:** The **MY\\_** prefix is the default prefix used to extend a class in CodeIgniter. If you have modified this in your **_application/config/config.php**, use your prefix as appropriate. and modify the MY_Model class\r\n\r\nNaming Conventions\r\n------------------\r\n\r\nThis class will try to guess the name of the table to use, by finding the plural of the class name.\r\n\r\nFor instance:\r\n\r\n    class Post_model extends MY_Model { }\r\n\r\n...will guess a table name of `posts`. It also works with `_m`:\r\n\r\n    class Book_m extends MY_Model { }\r\n\r\n...will guess `books`.\r\n\r\nIf you need to set it to something else, you can declare the _$\\_table_ instance variable and set it to the table name:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $_table = 'blogposts';\r\n    }\r\n\r\nSome of the CRUD functions will try to guess your primary key ID column. You can overwrite this functionality by setting the _$primary\\_key_ instance variable:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $primary_key = 'post_id';\r\n    }\r\n\r\nCallbacks/Observers\r\n-------------------\r\n\r\nThere are many times when you'll need to alter your model data before it's inserted or returned. This could be adding timestamps, pulling in relationships or deleting dependent rows. The MVC pattern states that these sorts of operations need to go in the model. In order to facilitate this, **CI_Base_Model** contains a series of callbacks/observers -- methods that will be called at certain points.\r\n\r\nThe default list of observers are as follows:\r\n\r\n* $before_create\r\n* $after_create\r\n* $before_update\r\n* $after_update\r\n* $before_get\r\n* $after_get\r\n* $before_delete\r\n* $after_delete\r\n\r\nThese are instance variables usually defined at the class level. They are arrays of methods on this class to be called at certain points. An example:\r\n\r\n```php\r\nclass Book_model extends MY_Model\r\n{\r\n    public $before_create = array( 'timestamps' );\r\n\r\n    protected function timestamps($book)\r\n    {\r\n        $book['created_at'] = $book['updated_at'] = date('Y-m-d H:i:s');\r\n        return $book;\r\n    }\r\n}\r\n```\r\n\r\n**Remember to always always always return the `$row` object you're passed. Each observer overwrites its predecessor's data, sequentially, in the order the observers are defined.**\r\n\r\nObservers can also take parameters in their name, much like CodeIgniter's Form Validation library. Parameters are then accessed in `$this->callback_parameters`:\r\n\r\n    public $before_create = array( 'data_process(name)' );\r\n    public $before_update = array( 'data_process(date)' );\r\n\r\n    protected function data_process($row)\r\n    {\r\n        $row[$this->callback_parameters[0]] = $this->_process($row[$this->callback_parameters[0]]);\r\n\r\n        return $row;\r\n    }\r\n\r\nValidation\r\n----------\r\n\r\nMY_Model uses CodeIgniter's built in form validation to validate data on insert.\r\n\r\nYou can enable validation by setting the `$validate` instance to the usual form validation library rules array:\r\n\r\n    class User_model extends MY_Model\r\n    {\r\n        public $validate = array(\r\n            array( 'field' => 'email',\r\n                   'label' => 'email',\r\n                   'rules' => 'required|valid_email|is_unique[users.email]' ),\r\n            array( 'field' => 'password',\r\n                   'label' => 'password',\r\n                   'rules' => 'required' ),\r\n            array( 'field' => 'password_confirmation',\r\n                   'label' => 'confirm password',\r\n                   'rules' => 'required|matches[password]' ),\r\n        );\r\n    }\r\n\r\nAnything valid in the form validation library can be used here. To find out more about the rules array, please [view the library's documentation](http://codeigniter.com/user_guide/libraries/form_validation.html#validationrulesasarray).\r\n\r\nWith this array set, each call to `insert()` or `update()` will validate the data before allowing  the query to be run. **Unlike the CodeIgniter validation library, this won't validate the POST data, rather, it validates the data passed directly through.**\r\n\r\nYou can skip the validation with `skip_validation()`:\r\n\r\n    $this->user_model->skip_validation();\r\n    $this->user_model->insert(array( 'email' => 'blah' ));\r\n\r\nAlternatively, pass through a `TRUE` to `insert()`:\r\n\r\n    $this->user_model->insert(array( 'email' => 'blah' ), TRUE);\r\n\r\nUnder the hood, this calls `validate()`.\r\n\r\nProtected Attributes\r\n--------------------\r\n\r\nIf you're lazy like me, you'll be grabbing the data from the form and throwing it straight into the model. While some of the pitfalls of this can be avoided with validation, it's a very dangerous way of entering data; any attribute on the model (any column in the table) could be modified, including the ID.\r\n\r\nTo prevent this from happening, MY_Model supports protected attributes. These are columns of data that cannot be modified.\r\n\r\nYou can set protected attributes with the `$protected_attributes` array:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $protected_attributes = array( 'id', 'hash' );\r\n    }\r\n\r\nNow, when `update` is called, the attributes will automatically be removed from the array, and, thus, protected:\r\n\r\n    $this->post_model->update(1, array(\r\n        'id' => 2,\r\n        'hash' => 'aqe3fwrga23fw243fWE',\r\n        'title' => 'A new post'\r\n    ));\r\n\r\n    // SQL: INSERT INTO posts (title) VALUES ('A new post')\r\n\r\nRelationships\r\n-------------\r\n\r\n**MY\\_Model** now has support for basic _belongs\\_to_ and has\\_many relationships. These relationships are easy to define:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $belongs_to = array( 'author' );\r\n        public $has_many = array( 'comments' );\r\n    }\r\n\r\nIt will assume that a MY_Model API-compatible model with the singular relationship's name has been defined. By default, this will be `relationship_model`. The above example, for instance, would require two other models:\r\n\r\n    class Author_model extends MY_Model { }\r\n    class Comment_model extends MY_Model { }\r\n\r\nIf you'd like to customise this, you can pass through the model name as a parameter:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $belongs_to = array( 'author' => array( 'model' => 'author_m' ) );\r\n        public $has_many = array( 'comments' => array( 'model' => 'model_comments' ) );\r\n    }\r\n\r\nYou can then access your related data using the `with()` method:\r\n\r\n    $post = $this->post_model->with('author')\r\n                             ->with('comments')\r\n                             ->get(1);\r\n\r\nThe related data will be embedded in the returned value from `get`:\r\n\r\n    echo $post->author->name;\r\n\r\n    foreach ($post->comments as $comment)\r\n    {\r\n        echo $message;\r\n    }\r\n\r\nSeparate queries will be run to select the data, so where performance is important, a separate JOIN and SELECT call is recommended.\r\n\r\nThe primary key can also be configured. For _belongs\\_to_ calls, the related key is on the current object, not the foreign one. Pseudocode:\r\n\r\n    SELECT * FROM authors WHERE id = $post->author_id\r\n\r\n...and for a _has\\_many_ call:\r\n\r\n    SELECT * FROM comments WHERE post_id = $post->id\r\n\r\nTo change this, use the `primary_key` value when configuring:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $belongs_to = array( 'author' => array( 'primary_key' => 'post_author_id' ) );\r\n        public $has_many = array( 'comments' => array( 'primary_key' => 'parent_post_id' ) );\r\n    }\r\n\r\nArrays vs Objects\r\n-----------------\r\n\r\nBy default, MY_Model is setup to return objects using CodeIgniter's QB's `row()` and `result()` methods. If you'd like to use their array counterparts, there are a couple of ways of customising the model.\r\n\r\nIf you'd like all your calls to use the array methods, you can set the `$return_type` variable to `array`.\r\n\r\n    class Book_model extends MY_Model\r\n    {\r\n        protected $return_type = 'array';\r\n    }\r\n\r\nIf you'd like just your _next_ call to return a specific type, there are two scoping methods you can use:\r\n\r\n    $this->book_model->as_array()\r\n                     ->get(1);\r\n    $this->book_model->as_object()\r\n                     ->get_by('column', 'value');\r\n\r\nSoft Delete\r\n-----------\r\n\r\nBy default, the delete mechanism works with an SQL `DELETE` statement. However, you might not want to destroy the data, you might instead want to perform a 'soft delete'.\r\n\r\nIf you enable soft deleting, the deleted row will be marked as `deleted` rather than actually being removed from the database.\r\n\r\nTake, for example, a `Book_model`:\r\n\r\n    class Book_model extends MY_Model { }\r\n\r\nWe can enable soft delete by setting the `$this->deleted_at_key` key:\r\n\r\n    class Book_model extends MY_Model\r\n    {\r\n        protected $deleted_at_key = 'deleted_at';\r\n    }\r\n\r\nBy default, MY_Model expects a `Datetime` or `TIMESTAMP` column named `deleted_at`. If you'd like to customise this, you can set `$deleted_at_key`:\r\n\r\n    class Book_model extends MY_Model\r\n    {\r\n        protected $deleted_at_key = 'book_deleted_at';\r\n    }\r\n\r\nIf you wish to track the deleted by you can set `$deleted_by_key` member,\r\n\r\n    class Book_model extends MY_Model\r\n    {\r\n        protected $deleted_at_key = 'book_deleted_at';\r\n        protected $deleted_by_key = 'book_deleted_by';\r\n    }\r\n\r\nNow, when you make a call to any of the `get_` methods, a constraint will be added to not withdraw deleted columns:\r\n\r\n    => $this->book_model->get_by('user_id', 1);\r\n    -> SELECT * FROM books WHERE user_id = 1 AND deleted < NOW()\r\n\r\nIf you'd like to include deleted columns, you can use the `with_deleted()` scope:\r\n\r\n    => $this->book_model->with_deleted()->get_by('user_id', 1);\r\n    -> SELECT * FROM books WHERE user_id = 1\r\n\r\nIf you'd like to include only the columns that have been deleted, you can use the `only_deleted()` scope:\r\n\r\n    => $this->book_model->only_deleted()->get_by('user_id', 1);\r\n    -> SELECT * FROM books WHERE user_id = 1 AND deleted >= NOW()\r\n\r\nYou can delete in future!!\r\n\r\n    => $this->book_model->delete_at(1, (new \\DateTime())->modify('+1 day'));\r\n\r\nBlamable\r\n--------\r\nTake, for example, a `Book_model`:\r\n\r\n    class Book_model extends MY_Model { }\r\n\r\nWe can enable blamable by setting the `$this->created_by_key` abd `$this->updated_by_key` key. And you need to implement the get_current_user() function, in the MY_Model\r\n\r\n    class Book_model extends MY_Model\r\n    {\r\n        protected $created_by_key = 'created_by';\r\n        protected $updated_by_key = 'updated_by';\r\n    }\r\n\r\n    class MY_Model extends CI_Base_Model{\r\n        protected $current_user_id_session_key = 'user_id';\r\n    }\r\n\r\nNow, when you make a call to any of the `insert`, `update`, `update_` methods the Model will automatically insert/update the created_by/updated_by entry\r\n\r\n    => $this->book_model->insert(array('title' => 'A new book'));\r\n    -> SQL: INSERT INTO books (title, updated_by) VALUES ('A new post', 1) //Assuming current user id is 1\r\n\r\n\r\nBuilt-in Observers\r\n-------------------\r\n\r\n**CI_Base_Model** contains a few built-in observers. The timestamps (MySQL compatible) `created_at` and `updated_at` are now available as built-in observers:\r\n\r\n    class Post_model extends MY_Model\r\n    {\r\n        public $before_create = array( 'created_at', 'updated_at' );\r\n        public $before_update = array( 'updated_at' );\r\n    }\r\n\r\n**CI_Base_Model** also contains serialisation observers for serialising and unserializing native PHP objects. This allows you to pass complex structures like arrays and objects into rows and have it be serialised automatically in the background. Call the `serialize` and `unserialize` observers with the column name(s) as a parameter:\r\n\r\n    class Event_model extends MY_Model\r\n    {\r\n        public $before_create = array( 'serialize_row(seat_types)' );\r\n        public $before_update = array( 'serialize_row(seat_types)' );\r\n        public $after_get = array( 'unserialize_row(seat_types)' );\r\n    }\r\n\r\nDatabase Connection\r\n-------------------\r\n\r\nThe class will automatically use the default database connection, and even load it for you if you haven't yet.\r\n\r\nYou can specify a database connection on a per-model basis by declaring the _$\\_db\\_group_ instance variable. This is equivalent to calling `$this->db->database($this->_db_group, TRUE)`.\r\n\r\nSee [\"Connecting to your Database\"](http://ellislab.com/codeigniter/user-guide/database/connecting.html) for more information.\r\n\r\n```php\r\nclass Post_model extends MY_Model\r\n{\r\n    public $_db_group = 'group_name';\r\n}\r\n```\r\n\r\nMethods\r\n=========\r\n\r\n* find_by($field, $value, $fields, $order)  [alias findBy]\r\n* find_by_{$field}($value, $fields, $order) [alias findBy{$field}]\r\n* find_all_by($field, $value, $fields, $order, $start, $limit)  [alias findAllBy]\r\n* find_all_by_{$field}($value, $fields, $order, $start, $limit) [alias findAllBy{$field}]\r\n* find_field_by($field, $value, $fields = '*', $order = NULL)   [alias findFieldBy]\r\n* find_field_by_{$field}($value, $fields = '*', $order = NULL)  [alias findFieldBy{$field}]\r\n* find_all($conditions, $fields, $order, $start, $limit)        [alias findAll]\r\n* find($conditions, $fields, $order)\r\n* field($conditions, $name, $fields, $order)\r\n* get($id)\r\n* get_all()\r\n* get_by()\r\n* get_many(array $primary_values)\r\n* get_many_by()\r\n* find_count($conditions) [alias findCount]\r\n* insert($data, $skip_validation = FALSE)\r\n* insert_many($data, $skip_validation = FALSE, $insert_individual = false)\r\n* update($primary_value, $data, $skip_validation = FALSE)\r\n* update_many($primary_values, $data, $skip_validation = FALSE)\r\n* update_by()\r\n* update_all($data)\r\n* update_batch($data, $where_key)\r\n* on_duplicate_update($data, $update)\r\n* delete($id)\r\n* delete_by() //argument can be in any form supported by $this->db->where();\r\n* delete_many(array $primary_values) [alias deleteMany]\r\n* delete_at($id, $time) [alias deleteAt]\r\n* delete_by_at($condition, $time) [alias deleteByAt]\r\n* delete_many_at(array $primary_values, $time) [alias deleteManyAt]\r\n* execute_query($query) [alias executeQuery]\r\n* order_by($orders) [alias orderBy]\r\n* dropdown() [can be called dropdown($name_field) or dropdown($key_field, $name_field)]\r\n* subscribe($event, $observer, $handler_name)\r\n* is_subscribed($event, $handler_name)\r\n\r\n\r\nUnit Tests\r\n----------\r\n\r\nMY_Model contains a robust set of unit tests to ensure that the system works as planned.\r\n\r\nInstall the testing framework (PHPUnit) with Composer:\r\n\r\n    $ curl -s https://getcomposer.org/installer | php\r\n    $ php composer.phar install\r\n\r\nYou can then run the tests using the `vendor/bin/phpunit` binary and specify the tests file:\r\n\r\n    $ vendor/bin/phpunit\r\n\r\n\r\nContributing to CI_Base_Model\r\n------------------------\r\n\r\nIf you find a bug or want to add a feature to CI_Base_Model, great! In order to make it easier and quicker for me to verify and merge changes in, it would be amazing if you could follow these few basic steps:\r\n\r\n1. Fork the project.\r\n2. **Branch out into a new branch. `git checkout -b name_of_new_feature_or_bug`**\r\n3. Make your feature addition or bug fix.\r\n4. **Add tests for it. This is important so I donâ€™t break it in a future version unintentionally.**\r\n5. Commit.\r\n6. Send me a pull request!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}